SELECT 'A' ||COLUMN_NAME||','
FROM USER_TAB_COLUMNS
WHERE TABLE_NAME = 'T1_DATA';

--결과
ANO,
AEMP_ID,
AEMP_NAME,
ASALARY,
ABIRTH_DATE,
ATABLE_NAME,
ATABLESPACE_NAME,
AYYMM_YM,
AITEM_CD,
ABUDGET_CD,
APROD_AM,


--데이터 100만개 생성
INSERT INTO T1_DATA
SELECT 999*B.NO + A.NO,
A.EMP_ID, A.EMP_NAME, A.SALARY, A.BIRTH_DATE, A.TABLE_NAME,
A.TABLESPACE_NAME, A.YYMM_YM, A.ITEM_CD, A.BUDGET_CD, A.PROD_AM
FROM T1_DATA A, T1_DATA B
WHERE B.NO <=1000;


/* 문제  1*/
1. EXT_NO 라는 시퀀스를 생성하되 1에서 시작해 증분은 1씩 최대 1000까지 증가하다 다시 1로 순환 채번 되도록 생성하며 메모리에 CACHE 하지 않습니다.

    CREATE SEQUENCE EXT_NO
        INCREMENT BY 1
        START WITH 1
        MAXVALUE 1000
        NOCACHE
        CYCLE;

2. SEQUENCE 생성 여부 DICTIONARY VIEW를 통해 확인

SELECT SEQUENCE_NAME, MIN_VALUE, MAX_VALUE, INCREMENT_BY, LAST_NUMBER
FROM USER_SEQUENCES;


3. EXT_NO 의 현재 SEQUENCE 값 확인 => 오류 확인


SELECT LAST_NUMBER
FROM USER_SEQUENCES
WHERE SEQUENCE_NAME = 'EXT_NO';


SELECT EXT_NO.CURRVAL
FROM DUAL;


4. EXT_NO 의 새로운 번호 채번

SELECT EXT_NO.NEXTVAL
FROM DUAL;


5. 3번 재실행으로 현재까지 채번 번호 확인

SELECT EXT_NO.CURRVAL
FROM DUAL;

NEXTVAL이 실행이 되야 다음 번호를 채번시킨다 그후에 CURRVAL을 실행시키면 채번된 번호를 알 수 있다



6. 세션과 USER간 동일 시퀀스를 이용한 채번을 통해 채번 규칙 확인
 (CURRVAL, NEXTVAL의 작동 방식이 상식적으로 ACCEPTABLE 한지)

 NEXTVAL 실행후 CURRVAL시 작동확인 


7. TEMP를 이용 SELECT 절에 EXT_NO의 NEXTVAL만을 SELECT 하여 CREATE TABLE TSEQ1 생성

CREATE TABLE TSEQ1 AS
SELECT EXT_NO.NEXTVAL
FROM TEMP;



8. ALTER 명령을 이용 EXT_NO를 CACHE 10 로 변경 후 DICTIONARY VIEW 확인 

ALTER SEQUENCE EXT_NO
      INCREMENT BY 1
      MAXVALUE 1000
      CACHE 10
      CYCLE;



SELECT SEQUENCE_NAME, MIN_VALUE, MAX_VALUE, INCREMENT_BY, LAST_NUMBER, CACHE_SIZE
FROM USER_SEQUENCES;




9. EXT_NO 에서 채번해 TSEQ1에 1건 INSERT 하기

SELECT EXT_NO.NEXTVAL
FROM DUAL;

INSERT INTO TSEQ1 VALUES (EXT_NO.NEXTVAL);



/*문제 2*/
1. USER_INDEXES 와 USER_IND_COLUMNS 를 이용 INDEX 를 조회하고 어떤 인덱스가 PRIMARY KEY 와 UNIQUE INDEX 이고 어느 것이 일반 인덱스 인지 구별 

    SELECT C.INDEX_NAME, C.COLUMN_NAME, C.COLUMN_POSITION, I.UNIQUENESS, D.CONSTRAINT_TYPE
    FROM USER_INDEXES I , USER_IND_COLUMNS C, USER_CONSTRAINTS D
    WHERE C.INDEX_NAME = I.INDEX_NAME
    AND C.TABLE_NAME = 'T1_DATA'
    AND D.CONSTRAINT_NAME(+) = I.INDEX_NAME;



SELECT C.INDEX_NAME, C.COLUMN_NAME, C.COLUMN_POSITION, I.UNIQUENESS
FROM USER_INDEXES I, USER_IND_COLUMNS C
WHERE C.INDEX_NAME = I.INDEX_NAME;


2. T1_DATA 의 NO 가 1000보다 작은 경우와 100000보다 작은 경우 300000 보다 작은 경우 등을 나누어
   QUERY 작성 후 ( 각각의 경우 INDEX SCAN 인지 FULL SCAN 인지 개별 확인)

SET AUTOTRACE ON
SET AUTOTRACE TRACEONLY EXPLAIN
SELECT NO,EMP_ID
FROM T1_DATA
WHERE NO<1000;

SET AUTOTRACE ON
SET AUTOTRACE TRACEONLY EXPLAIN
SELECT NO,EMP_ID
FROM T1_DATA
WHERE NO<100000;

SET AUTOTRACE ON
SET AUTOTRACE TRACEONLY EXPLAIN
SELECT NO,EMP_ID
FROM T1_DATA
WHERE NO<300000;



3. T1_DATA의 SALARY, TABLE_NAME 컬럼에 T1_INX1 이름으로 복합인덱스 생성
   (DICTIONARY VIEW 에서 개별 확인)

CREATE INDEX T1_INX1 ON T1_DATA(SALARY, TABLE_NAME);

   
SELECT C.INDEX_NAME, C.COLUMN_NAME, C.COLUMN_POSITION, I.UNIQUENESS
FROM USER_INDEXES I, USER_IND_COLUMNS C
WHERE C.INDEX_NAME = I.INDEX_NAME
AND C.INDEX_NAME = 'T1_INX1'
;

   
4. T1_DATA 에서 SALARY 가 3천만원인 경우와 3천만원보다 작은 경우 쿼리 작성
 ( 각각의 경우 INDEX SCAN 인지 FULL SCAN 인지 개별 확인 하고 인덱스 스캔인 경우 정렬 확인) 




SET AUTOTRACE ON -- = SELECT PLAN_TABLE_OUTPUT FROM TABLE(DBMS_XPLAN.DISPLAY());
SET AUTOTRACE TRACEONLY EXPLAIN
SELECT SALARY
FROM T1_DATA
WHERE SALARY > 30000000;

SET AUTOTRACE ON -- =SELECT PLAN_TABLE_OUTPUT FROM TABLE(DBMS_XPLAN.DISPLAY());
SET AUTOTRACE TRACEONLY EXPLAIN
SELECT SALARY
FROM T1_DATA
WHERE SALARY = 30000000;



--INDEX 조건으로 SALARY 와 TABLENAME을 같이 주었기 때문에 WHERE 절에도 조건 2개를 모두 걸어줘야 인덱스 스캔한다.
--여기서 TABLE NAME에는 TEMP가 없지만 TABLE_NAME 조건을 주기 위해 넣음
SET AUTOTRACE ON
SET AUTOTRACE TRACEONLY EXPLAIN
SELECT SALARY
FROM T1_DATA
WHERE SALARY = 30000000
AND   TABLE_NAME = 'TEMP';

같은것

SELECT PLAN_TABLE_OUTPUT FROM TABLE(DBMS_XPLAN.DISPLAY());
SELECT SALARY
FROM T1_DATA
WHERE SALARY = 30000000
AND   TABLE_NAME = 'TEMP';



-- ~~~~~ SALARY = 3000000 ~~~~~~~~~~
EXPLAIN PLAN FOR
SELECT * FROM T1_DATA WHERE SALARY = 3000000;
SELECT PLAN_TABLE_OUTPUT FROM TABLE(DBMS_XPLAN.DISPLAY());

-- ~~~~~~~~~ SALARY < 30000000~~~~~~~~
EXPLAIN PLAN FOR
SELECT * FROM T1_DATA WHERE SALARY < 30000000;
SELECT PLAN_TABLE_OUTPUT FROM TABLE(DBMS_XPLAN.DISPLAY());








5. SALARY의 천만 단위가 같으면 같은 값으로 간주하여 직급, 천만단위급여, 이름 순으로 정렬을 하되, INDEX를 이용한 정렬을 하고 싶은 경우 인덱스 생성

CREATE INDEX TSAL
ON TEMP(LEV,TRUNC(SALARY/10000000,0)*1000000,EMP_NAME);


SET AUTOTRACE ON
SET AUTOTRACE TRACEONLY EXPLAIN
SELECT  B.LEV, TRUNC(B.SALARY/10000000,0)*10000000 , B.EMP_NAME 
FROM TEMP A, TEMP B
WHERE TRUNC(A.SALARY/10000000,0) = TRUNC(B.SALARY/10000000,0)
GROUP BY B.LEV, TRUNC(B.SALARY/10000000,0)*10000000, B.EMP_NAME 
ORDER BY B.LEV, TRUNC(B.SALARY/10000000,0)*10000000 DESC, B.EMP_NAME ;


--인덱스 힌트 써서강제 스캔
CREATE INDEX LEV_IDX
ON TEMP(LEV,TRUNC(SALARY/10000000)*10000000,EMP_NAME);

SELECT  /*+INDEX(TEMP,LEV_IDX ) */ LEV,TRUNC(SALARY/10000000)*10000000,EMP_NAME
FROM   TEMP
WHERE  LEV > ' ';



6. STUDY02에서 STUDY01의 TEMP 에 대한 PUBLIC SYNONYM 을 TEMP 라는 이름으로 생성

CREATE PUBLIC SYNONYM TEMP
FOR STUDY01.TEMP;


7. STUDY02에서 STUDY01의 TDEPT 에 대한 일반 SYNONYM 을 TDEPT 라는 이름으로 

CREATE SYNONYM TDEPT
FOR STUDY01.TDEPT;


8. STUDY03에서 SCHEMA 지정 없이 TEMP와 TDEPT에서 각각 SELECT 결과 확인

SELECT * FROM TEMP;

SELECT * FROM TDEPT;